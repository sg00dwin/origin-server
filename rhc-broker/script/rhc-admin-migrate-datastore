#!/usr/bin/env oo-ruby
require 'getoptlong'

VERSIONS = {
  '2.0.32' => {
    :compatible => false,
    :non_compatible => true,
    :prerelease => false,
    :postrelease => false
  }
}

CARTRIDGE_CHANGES = [{"old_name" => "phpmyadmin-3", "new_name" => "phpmyadmin-4", "old_version" => "3", "new_version" => "4"}]

def migrate(type, version)
  puts "Starting migration: #{type}"
  case type
  when :prerelease
  when :postrelease
  when :non_compatible
    adjust_cartridge_versions
  end
  puts "\nMigration complete"
end

#
# Update old cartridge names to be simpler
#
def adjust_cartridge_versions
  CARTRIDGE_CHANGES.each do |cart_change|
    puts "Updating cartridge #{cart_change['old_name']} to #{cart_change['new_name']}"

    print "Updating component instances for all applications...\t"
    update_component_instances(cart_change['old_name'], cart_change['new_name'])
    puts "Done."

    print "Updating group overrides for all applications...\t"
    update_group_overrides(cart_change['old_name'], cart_change['new_name'])
    puts "Done."

    print "Updating cartridge version for all applications...\t"
    update_cartridge_version(cart_change['new_name'], cart_change['old_version'], cart_change['new_version'])
    puts "Done."

    print "Updating cartridge version for premium cartridges in usage...\t"
    update_premium_cart_version(cart_change['old_name'], cart_change['new_name'])
    puts "Done."

    print "Verifying cartridge update for all applications...\t"
    missed_update_count = verify_migration(cart_change['old_name'], cart_change['new_name'], cart_change['old_version'])
    puts missed_update_count == 0 ? "Successful." : "Failed."
    puts ""
  end
end


def update_component_instances(old_cart_name, new_cart_name)
  ci_index = 0
  ci_search_count = 1
  while ci_search_count > 0 do
    filter = {"component_instances.#{ci_index}.cartridge_name" => old_cart_name}
    update_query = {"$set" => {"component_instances.#{ci_index}.cartridge_name" => new_cart_name,
                               "component_instances.#{ci_index}.component_name" => new_cart_name}}
    db["applications"].update(filter, update_query, { :multi => true })

    ci_index += 1
    ci_search_count = db["applications"].find({"component_instances.#{ci_index}" => {"$exists" => true}}).count
  end
end

def update_group_overrides(old_cart_name, new_cart_name)
  # Update all the cartridge names in group_overrides
  go_index = 0
  go_search_count = 1
  while go_search_count > 0 do
    component_index = 0
    component_search_count = 1
    while component_search_count > 0
      filter = {"group_overrides.#{go_index}.components.#{component_index}.cart" => old_cart_name}
      update_query = {"$set" => {"group_overrides.#{go_index}.components.#{component_index}.cart" => new_cart_name,
                                 "group_overrides.#{go_index}.components.#{component_index}.comp" => new_cart_name}}
      db["applications"].update(filter, update_query, { :multi => true })
      component_index += 1
      component_search_count = db["applications"].find({"group_overrides.#{go_index}.components.#{component_index}" => {"$exists" => true}}).count
    end
    go_index += 1
    go_search_count = db["applications"].find({"group_overrides.#{go_index}.components.0" => {"$exists" => true}}).count
  end
end

def update_cartridge_version(new_cart_name, old_cart_version, new_cart_version)
  ci_index = 0
  ci_search_count = 1
  while ci_search_count > 0 do
    filter = {"component_instances.#{ci_index}.cartridge_name" => new_cart_name,
              "component_instances.#{ci_index}.cartridge_vendor" => "redhat",
              "component_instances.#{ci_index}.version" => old_cart_version}
    update_query = {"$set" => {"component_instances.#{ci_index}.version" => new_cart_version}}
    db["applications"].update(filter, update_query, { :multi => true })

    ci_index += 1
    ci_search_count = db["applications"].find({"component_instances.#{ci_index}" => {"$exists" => true}}).count
  end
end

def update_premium_cart_version(old_cart_name, new_cart_name)
  filter = {"cart_name" => old_cart_name}
  update_query = {"$set" => {"cart_name" => new_cart_name}}

  db["usage"].update(filter, update_query, { :multi => true })
  db["usage_records"].update(filter, update_query, { :multi => true })
end

def verify_migration(old_cart_name, new_cart_name, old_cart_version)
  missed_update_count = 0
  missed_update_count += db["applications"].find({"component_instances.cartridge_name" => old_cart_name}).count
  missed_update_count += db["applications"].find({"component_instances.component_name" => old_cart_name}).count
  missed_update_count += db["applications"].find({"group_overrides.components.cart" => old_cart_name}).count
  missed_update_count += db["applications"].find({"group_overrides.components.comp" => old_cart_name}).count
  missed_update_count += db["applications"].find({"component_instances" => {"$elemMatch" => {"cartridge_name" => new_cart_name, "cartridge_vendor" => "redhat", "version" => old_cart_version}}}).count
  missed_update_count += db["usage"].find({"cart_name" => old_cart_name}).count
  missed_update_count += db["usage_records"].find({"cart_name" => old_cart_name}).count

  missed_update_count
end

#------------------------------------------------------------------
#
# Migration core code
#
def db
  $db ||= OpenShift::DataStore.db(:primary)
end

def check_compatible(type, v)
  if version = VERSIONS[v]
    if version[type]
      [true]
    else
      [false, "Migration #{type} for version #{v} is not supported!"]
    end
  else
    [false, "Migration of version '#{v}' not supported!"]
  end
end

def p_usage
  puts <<USAGE

Usage: #{$0}

  --version                            Version of the migration to run
  --compatible                         Run the backwards compatible portion of the migration (Can be run after the system is upgrade with the brokers running)
  --prerelease                         Run the pre release portion of the migration (Can be run at any time, and is reentrant)
  --non-compatible                     Run the non backwards compatible portion of the migration (Must be run with the brokers shutdown)
  --postrelease                        Run the post release portion of the migration (can be run with brokers online, but node migration should have completed successfully)
  --check                              Check whether the compatible or non compatible portion of the migration is necessary (Returns 0 if necessary)
  --help                               Show usage info
USAGE
  exit 255
end

begin
  opts = GetoptLong.new(
    ["--version", "-v", GetoptLong::REQUIRED_ARGUMENT],
    ["--compatible", "-c", GetoptLong::NO_ARGUMENT],
    ["--non-compatible", "-n", GetoptLong::NO_ARGUMENT],
    ["--prerelease", "-p", GetoptLong::NO_ARGUMENT],
    ["--postrelease", "-o", GetoptLong::NO_ARGUMENT],
    ["--check", GetoptLong::NO_ARGUMENT],
    ["--help", "-h", GetoptLong::NO_ARGUMENT]
  )
  opt = {}
  opts.each do |o, a|
    opt[o[2..-1]] = a.to_s
  end
rescue Exception => e
  p_usage
end

if opt['help']
  p_usage
end

unless opt['version']
  puts "version is required!"
  p_usage
end

unless opt['compatible'] || opt['non-compatible'] || opt['prerelease'] || opt['postrelease']
  puts "compatible or non-compatible or prerelease or postrelease is required!"
  p_usage
end

if [opt['compatible'],opt['non-compatible'],opt['prerelease'],opt['postrelease']].compact.count > 2
  puts "compatible, non-compatible, prerelease and postrelease are mutually exclusive."
  p_usage
end

version_number = opt['version']
unless version = VERSIONS[version_number]
  puts "Migration of version '#{version_number}' not supported!"
  exit 1
end

type = ((opt['compatible'] and :compatible) or (opt['non-compatible'] and :non_compatible) or (opt['prerelease'] and :prerelease) or (opt['postrelease'] and :postrelease))

if opt['check']
  success, _ = check_compatible(type, version_number)
  exit success ? 0 : 1
end

success, msg = check_compatible(type, version_number)
unless success
  puts msg
  exit 1
end

$:.unshift('/var/www/openshift/broker')
require 'config/environment'

migrate(type, version)

puts "Done!"
