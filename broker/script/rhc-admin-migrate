#!/usr/bin/env ruby
require 'rubygems'
require 'pp'
require 'thread'
require 'thread-dump'
require 'getoptlong'
require 'stringio'
require 'set'

$max_threads = 8
WORK_DIR = '/tmp/rhc/migration'

# For each of these sets:  nil implies all and empty implies none

MIGRATION_CART_TYPES = ['mongodb-2.2','python-2.6', 'jenkins-1.4'].to_set
RESTART_CART_TYPES = ['jenkins-1.4','mongodb-2.2','python-2.6'].to_set
REDEPLOY_HTTPD_PROXY_CART_TYPES = [].to_set # Deploys on top of existing config.  Will not fixup renames.

$all_cart_types = nil
if MIGRATION_CART_TYPES && RESTART_CART_TYPES && REDEPLOY_HTTPD_PROXY_CART_TYPES
  $all_cart_types = Set.new
  $all_cart_types = MIGRATION_CART_TYPES + RESTART_CART_TYPES + REDEPLOY_HTTPD_PROXY_CART_TYPES
end

STDOUT.sync, STDERR.sync = true

#
#  Migrate the specified gear
#
def migrate_gear(rhlogin, app_name, gear_uuid, version)
  migrate_cmd = "#{__FILE__} --rhlogin '#{rhlogin}' --migrate-gear '#{gear_uuid}' --app-name '#{app_name}' --version '#{version}'"
  out = StringIO.new
  out << "Migrating gear on node with: #{migrate_cmd}\n"
  begin
    user = CloudUser.find(rhlogin)
    if user
      app = Application.find(user, app_name)
      if app
        gear = nil
        app.gears.each do |app_gear|
          if app_gear.uuid == gear_uuid
            gear = app_gear
            break
          end
        end
        if gear
          server_identity = gear.server_identity
          gear.node_profile = app.node_profile if gear.node_profile.nil?
          is_haproxy_gear = false
          begin
            Timeout::timeout(240) do
              output = ''
              exit_code = 1
              migrate = MIGRATION_CART_TYPES.nil? 
              MIGRATION_CART_TYPES.each do |cart_name|
                if gear.cartridges.include?(cart_name)
                  migrate = true
                  break
                end
              end unless migrate

              # Handle case where its a scalable app's secondary gears. We
              # want to disable idling those for now. So migrate all gears for
              # scalable apps.
              migrate = true  if app.scalable
              is_haproxy_gear = true if gear.cartridges.include?("haproxy-1.4")

              if migrate
                out << "Migrating on node...\n"
                GearChanger::MCollectiveApplicationContainerProxy.rpc_exec('libra', server_identity) do |client|
                  client.migrate(:uuid => gear_uuid,
                                 :namespace => app.domain.namespace,
                                 :version => version) do |response|
                    exit_code = response[:body][:data][:exitcode]
                    output = response[:body][:data][:output]
                  end
                end
              end
              if (output.length > 0)
                out << "Migrate on node output: #{output}\n"
              end
              if migrate && exit_code != 0
                out << "Migrate on node exit code: #{exit_code}\n"
                raise "Failed migrating gear. Rerun with: #{migrate_cmd}"
              else
                redeploy_httpd_proxy = REDEPLOY_HTTPD_PROXY_CART_TYPES.nil?

                if REDEPLOY_HTTPD_PROXY_CART_TYPES
                  gear_cartridges = gear.cartridges
                  REDEPLOY_HTTPD_PROXY_CART_TYPES.each do |cart_name|
                    redeploy_httpd_proxy = gear_cartridges.include?(cart_name)
                    break if redeploy_httpd_proxy
                  end unless redeploy_httpd_proxy
                end

                #remove_httpd_proxy(gear, out)
                redeploy_httpd_proxy(gear, out) if redeploy_httpd_proxy
                #redeploy_aliases(gear, out)

                gear.configured_components.each do |comp_name|
                  restart = RESTART_CART_TYPES.nil?
                  RESTART_CART_TYPES.each do |cart_name|
                    if comp_name =~ /\/cart-#{cart_name}\/?/
                      restart = true
                      break
                    end
                  end unless restart
                  if restart
                    component = app.comp_instance_map[comp_name]
                    restart_component(gear, component, out)
                  end
                end
              end
            end
          rescue Timeout::Error
            raise "Command '#{migrate_cmd}' timed out"
          end
          if app.scalable  &&  is_haproxy_gear
            app.elaborate_descriptor
            app.execute_connections
          end
        else
          out << "WARNING: Gear not found with uuid #{gear_uuid} for app '#{app_name}' and user '#{rhlogin}'\n"
        end
      else
        raise "App not found: #{app_name}"
      end
    else
      raise "User not found: #{rhlogin}"
    end
  rescue Exception => e
    raise "#{e.message}\n#{e.backtrace}\nOutput:\n#{out.string}"
  end
  out.string
end

def restart_component(gear, component, out)
  leave_stopped = false
  reply = gear.status(component)
  reply.cart_commands.each do |command_item|
    case command_item[:command]
    when "ATTR"
      key = command_item[:args][0]
      value = command_item[:args][1]
      if key == 'status'
        case value
        when "ALREADY_STOPPED"
          leave_stopped = true
        when "ALREADY_IDLED"
          leave_stopped = true
        end
      end
    end
  end
  unless leave_stopped
    begin
      out << "Stopping component '#{component.name}' on gear with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
      reply.append gear.stop(component)
    rescue Exception => e
      out << "WARNING: Error stopping component '#{component.name}' on gear with uuid '#{gear.uuid}' on node '#{gear.server_identity}': #{e.message}\n"
    end
    begin
      out << "Force stopping component '#{component.name}' on gear with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
      reply.append gear.force_stop(component)
    rescue Exception => e
      out << "WARNING: Error force stopping component '#{component.name}' on gear with uuid '#{gear.uuid}' on node '#{gear.server_identity}': #{e.message}\n"
    end
    num_tries = 2
    (1..num_tries).each do |i|
      out << "Restarting component '#{component.name}' on gear with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
      begin
        reply.append gear.restart(component)
        break
      rescue Exception => e
        if i == num_tries
          out << "Failed to restart component '#{component.name}' on gear with uuid '#{gear.uuid}' on node '#{gear.server_identity}' after #{num_tries} tries with exception: #{e.message}\n"
          raise
        end
      end
    end
  else
    out << "Leaving component stopped '#{component.name}' on gear with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
  end
  out << "RESTART DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
  out << "RESTART ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
end

def redeploy_httpd_proxy(gear, out)
  httpd_proxy_action(gear, 'deploy-httpd-proxy', out)
end

def remove_httpd_proxy(gear, out)
  httpd_proxy_action(gear, 'remove-httpd-proxy', out)
end

def httpd_proxy_action(gear, action, out)
  gear.configured_components.each do |comp_name|
    component = gear.app.comp_instance_map[comp_name]
    out << "#{action} for '#{component.parent_cart_name}' on gear '#{gear.name}' with uuid '#{gear.uuid}' on node #{gear.server_identity}\n"
    embedded = gear.app.embedded.include?(component.parent_cart_name)
    reply = gear.app.container.send(:run_cartridge_command, (embedded ? "embedded/" : '') + component.parent_cart_name, gear.app, gear, action, nil, false)

    out << "DEPLOY_HTTP_PROXY DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
    out << "DEPLOY_HTTP_PROXY ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
    
    if reply.exitcode != 0
      out << "#{action} for cart: #{component.parent_cart_name} on node exit code: #{reply.exitcode}\n"
      raise "Failed deploying httpd proxy for gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'"
    end
  end
end

def redeploy_aliases(gear, out)
  unless gear.app.aliases.nil?
    gear.app.aliases.each do |server_alias|
      out << "Adding alias '#{server_alias}' for '#{gear.name}' with uuid '#{gear.uuid}' on node #{gear.server_identity}\n"
      reply = gear.add_alias(server_alias)
      out << "ADD_ALIAS DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
      out << "ADD_ALIAS ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
      if reply.exitcode != 0
        out << "Add alias on node exit code: #{reply.exitcode}\n"
        raise "Failed adding alias #{server_alias} for gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'"
      end
    end
  end
end

def migrate(version, continue=false, target_server_identity=nil, migrate_position=1, num_migrators=1)
  start_time = Time.now.to_i
  puts "Getting all RHLogins..."
  rhlogins_cnt = 0
  gear_cnt = 0
  node_to_gears = {}
  CloudUser.find_all(nil, {:with_gears => true}) {|hash|
    user = CloudUser.hash_to_obj(hash)
    rhlogins_cnt += 1
    puts "Gathering gears for user: #{user.login} with uuid: #{user.uuid}"
    apps = user.applications
    apps.each do |app|
      gears = app.gears
      if gears && !gears.empty?
        gears.each do |gear|
          server_identity = gear.server_identity
          if (!target_server_identity || (server_identity == target_server_identity))
            gear.cartridges.each do |cart_name|
              if $all_cart_types.nil? || $all_cart_types.include?(cart_name) || app.scalable
                node_to_gears[server_identity] = [] unless node_to_gears[server_identity]
                node_to_gears[server_identity] << {:server_identity => server_identity, :uuid => gear.uuid, :name => gear.name, :app_name => gear.app.name, :login => user.login}
                gear_cnt += 1 
                break
              end
            end
          end
        end
      else
        puts "ERROR: Gear not found for app: '#{app.name}' of user #{user.login}"
      end
    end
  }
  puts "RHLogins.length: #{rhlogins_cnt.to_s}"

  position = migrate_position - 1
  migrator_position_nodes = []
  if num_migrators > 1
    server_identities = node_to_gears.keys.sort 
    server_identities.each_with_index do |server_identity, index|
      if index == position
        migrator_position_nodes << server_identity
        position += num_migrators
      else
        node_to_gears.delete(server_identity)
      end
    end
  end

  gear_cnts = []
  thread_groups = []
  node_to_gears.each do |server_identity, gears|
    if thread_groups.length < $max_threads
      thread_groups << [{server_identity => gears}]
      gear_cnts << gears.length
    else
      min_pos = 0
      min = gear_cnts[0]
      gear_cnts.each_with_index do |cnt, index|
        if cnt < min
          min = cnt
          min_pos = index
        end
      end
      thread_groups[min_pos] << {server_identity => gears}
      gear_cnts[min_pos] += gears.length
    end
    node_to_gears[server_identity] = nil
  end
  
  puts "#####################################################"
  puts 'Gear counts per thread:'
  puts gear_cnts.pretty_inspect
  if !migrator_position_nodes.empty?
    puts 'Nodes this migrator is handling:'
    puts migrator_position_nodes.pretty_inspect
  end
  puts "#####################################################"
  
  thread_groups.each do |thread_group|
    thread_group.each do |node_to_gears|
      node_to_gears.each do |server_identity, gears|
        write_node_to_file(server_identity, gears, version) unless continue
        node_to_gears[server_identity] = nil
      end
    end
  end

  @failures = []
  node_threads = []
  thread_groups.each do |thread_group|
    node_threads << Thread.new do
      thread_group.each do |node_to_gears|
        node_to_gears.each do |server_identity, gears|
          migrate_node(server_identity, continue)
        end
      end
    end
  end

  node_threads.each do |t|
    t.join
  end
  
  if @failures.length > 0
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts "Failures:"
    @failures.each do |failure|
      puts failure
    end
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts ""
  end

  node_to_gears.each do |server_identity, gears|
    f = migrate_file_path(server_identity)
    leftover_count = `wc -l #{f}`.to_i
    if leftover_count > 0
      puts "!!!!!!!!!!WARNING!!!!!!!!!!!!!WARNING!!!!!!!!!!!!WARNING!!!!!!!!!!"
      puts "#{leftover_count} leftover gears found in migrate file: #{f}"
      puts "You can run with --continue to try again"
      puts "!!!!!!!!!!WARNING!!!!!!!!!!!!!WARNING!!!!!!!!!!!!WARNING!!!!!!!!!!"
      puts ""
    end
  end
  
  puts "#####################################################"
  puts "Summary:"
  puts "# of users: #{rhlogins_cnt}"
  puts "# of gears: #{gear_cnt}"
  puts "# of failures: #{@failures.length}"
  puts "Gear counts per thread: #{gear_cnts.pretty_inspect}"
  puts "Nodes migrated: #{migrator_position_nodes.pretty_inspect}" if !migrator_position_nodes.empty?

  end_time = Time.now.to_i
  total_time = end_time-start_time
  puts "Total execution time: #{total_time.to_s}s"
  puts "#####################################################"
end

def write_node_to_file(server_identity, gears, version)
  f = migrate_file_path(server_identity)
  puts "Writing #{gears.length} gears for node #{server_identity} to file #{f}"
  FileUtils.mkdir_p WORK_DIR
  FileUtils.rm_f f
  FileUtils.touch f
  gears.each_with_index do |gear, index|
    migrate_on_node_args = "#{gear[:server_identity]},#{gear[:uuid]},#{gear[:name]},#{gear[:app_name]},#{gear[:login]},#{version}"
    append_to_file(f, migrate_on_node_args)
  end
end

def error_file_path(server_identity)
  "#{WORK_DIR}/migrate_errors_#{server_identity}"
end

def log_file_path(server_identity)
  "#{WORK_DIR}/migrate_log_#{server_identity}"
end

def migrate_file_path(server_identity)
  "#{WORK_DIR}/migrate_#{server_identity}"
end

def migrate_node(server_identity, continue)
  puts "Migrating gears on node #{server_identity}"
  error_file = error_file_path(server_identity)
  FileUtils.rm_f error_file unless continue
  FileUtils.touch error_file
  log_file = log_file_path(server_identity)
  FileUtils.rm_f log_file unless continue
  FileUtils.touch log_file
  f = migrate_file_path(server_identity)
  migrate_node_cmd = "#{__FILE__} --migrate-file '#{f}'"
  output, exit_code = execute_script(migrate_node_cmd)
  puts output
  file = File.open(error_file, "r")
  begin
    while (line = file.readline)
      @failures << line.chomp
    end
  rescue EOFError
    file.close
  end
  file = File.open(log_file, "r")
  begin
    while (line = file.readline)
      print line
    end
  rescue EOFError
    file.close
  end
end

def migrate_from_file(file)
  while true
    line = File.open(file, &:gets)
    if line && !line.empty?
      params = line.chomp.split(',')
      server_identity = params[0] 
      gear_uuid = params[1]
      gear_name = params[2]
      app_name = params[3]
      rhlogin = params[4]
      version = params[5]
      migrate_on_node_cmd = "#{__FILE__} --rhlogin '#{rhlogin}' --migrate-gear '#{gear_uuid}' --app-name '#{app_name}' --version '#{version}'"
      error_file = error_file_path(server_identity)
      log_file = log_file_path(server_identity)
      append_to_file(log_file,  "Migrating app '#{app_name}' gear '#{gear_name}' with uuid '#{gear_uuid}' on node '#{server_identity}' for user: #{rhlogin}")
      num_tries = 2
      (1..num_tries).each do |i|
        begin
          output = migrate_gear(rhlogin, app_name, gear_uuid, version)
          append_to_file(log_file, output)
          break
        rescue Exception => e
          if i == num_tries
            append_to_file(log_file, "Failed to migrate with cmd: '#{migrate_on_node_cmd}' after #{num_tries} tries with exception: #{e.message}")
            append_to_file(error_file, migrate_on_node_cmd)
            break
          else
            if StickShift::DataStore.instance.find(Application.name, rhlogin, app_name)
              sleep 4
            else
              append_to_file(log_file, "App '#{app_name}' no longer found in datastore with uuid '#{gear_uuid}'.  Ignoring...")
              break
            end
          end
        end
      end
      `sed -i '1,1d' #{file}`
    else
      break
    end
  end
end

def self.append_to_file(f, value)
  file = File.open(f, 'a')
  begin
    file.puts value
  ensure
    file.close
  end
end

def execute_script(cmd, num_tries=1, timeout=28800)
  exitcode = nil
  output = ''
  (1..num_tries).each do |i|
    pid = nil
    begin
      Timeout::timeout(timeout) do
        read, write = IO.pipe
        pid = fork {
          # child
          $stdout.reopen write
          read.close
          exec(cmd)
        }
        # parent
        write.close
        read.each do |line|
          output << line
        end
        Process.waitpid(pid)
        exitcode = $?.exitstatus
      end
      break
    rescue Timeout::Error
      begin
        Process.kill("TERM", pid) if pid
      rescue Exception => e
        puts "execute_script: WARNING - Failed to kill cmd: '#{cmd}' with message: #{e.message}"
      end
      puts "Command '#{cmd}' timed out"
      raise if i == num_tries
    end
  end
  return output, exitcode
end

def p_usage
    puts <<USAGE

Usage: #{$0}

  --rhlogin rhlogin                    User rhlogin
  --migrate-gear gear_uuid             Gear uuid of the single gear to migrate
  --app-name app_name                  App name of the gear to migrate
  --migrate-node server_identity       Server identity of the node to migrate
  --migrate-file file                  File containing the gears to migrate
  --num-migrators num                  The total number of migrators to be run.  Each migrate-position will be a 
                                       migrate-position of num-migrators.  All positions must to taken to migrate
                                       all gears.  Ex: If you are going to run 2 migrators you would need to run:
                                       ./rhc-admin-migrate --version <version> --position 1 --num-migrators 2
                                       ./rhc-admin-migrate --version <version> --position 2 --num-migrators 2
  --migrate-position position          Postion of this migrator (1 based) amongst the num of migrators (--num_migrators)
  --max-threads num                    Indicates the number of processing queues
  --continue                           Flag indicating to continue a previous migration

USAGE
exit 255
end

begin
  opts = GetoptLong.new(
    ["--rhlogin", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrate-gear", GetoptLong::REQUIRED_ARGUMENT],
    ["--app-name", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrate-node", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrate-file", GetoptLong::REQUIRED_ARGUMENT],
    ["--version", GetoptLong::REQUIRED_ARGUMENT],
    ["--num-migrators", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrate-position", GetoptLong::REQUIRED_ARGUMENT],
    ["--max-threads", GetoptLong::REQUIRED_ARGUMENT],
    ["--continue", GetoptLong::NO_ARGUMENT],
    ["--help", "-h", GetoptLong::NO_ARGUMENT]
  )
  opt = {}
  opts.each do |o, a|
    opt[o[2..-1]] = a.to_s
  end
rescue Exception => e
  p_usage
end

if opt['help']
  p_usage
end

$:.unshift('/var/www/stickshift/broker')
require 'config/environment'
# Disable analytics for admin scripts
Rails.configuration.analytics[:enabled] = false

if opt['max_threads']
  max_threads = opt['max_threads'].to_i
  if max_threads < 50 && max_threads > 0
    $max_threads = max_threads
  else
    puts "max_threads must be less than 50 and greater than 0"
    exit 255
  end
end

if opt['migrate-file']
  migrate_from_file(opt['migrate-file'])
elsif opt['migrate-gear']
  if opt['rhlogin'] && opt['app-name'] && opt['version']
    puts migrate_gear(opt['rhlogin'], opt['app-name'], opt['migrate-gear'], opt['version'])
  else
    puts "--rhlogin, --app-name, and --version is required with --migrate-gear"
    exit 255
  end
elsif opt['migrate-node']
  if opt['version']
    migrate_file = migrate_file_path(opt['migrate-node'])
    if opt['continue']
      migrate(opt['version'], true, opt['migrate-node'])
    elsif File.exists?(migrate_file)
        puts <<-WARNING
!!!!!!!!!!!!!!!!!!!! EXISTING MIGRATION DATA FOUND !!!!!!!!!!!!!!!!!!!!
Data from a previous migration exists at #{migrate_file}.  You must 
either move/remove (Ex: rm #{migrate_file}) that data or pick up
where it left off with '#{__FILE__} --migrate-node #{opt['migrate-node']} --version '#{opt['version']}' --continue'.
WARNING
        exit 1
    else
      migrate(opt['version'], false, opt['migrate-node'])
    end
  else
    puts "--version is required with --migrate-node"
    exit 255
  end
else
  if opt['version']
    num_migrators = opt['num-migrators']
    migrate_position = opt['migrate-position']
    if num_migrators || migrate_position
      unless num_migrators
        puts "--num-migrators is required with --migrate-position"
        exit 255
      end
      unless migrate_position
        puts "--migrate-position is required with --num-migrators"
        exit 255
      end
      num_migrators = num_migrators.to_i
      migrate_position = migrate_position.to_i
      unless migrate_position > 0 && migrate_position <= num_migrators
        puts "migrate-position must be > 0 and <= num_migrators"
        exit 255
      end
      unless num_migrators > 0
        puts "num_migrators must be > 0"
        exit 255
      end
    else
      num_migrators = 1
      migrate_position = 1
    end
    if opt['continue']
      migrate(opt['version'], true, nil, migrate_position, num_migrators)
    elsif File.exists?("/tmp/rhc/migration")
      puts <<-WARNING
!!!!!!!!!!!!!!!!!!!! EXISTING MIGRATION DATA FOUND !!!!!!!!!!!!!!!!!!!!
Data from a previous migration exists at /tmp/rhc/migration.  You must 
either move/remove (Ex: rm -rf /tmp/rhc/migration) that data or pick up
where it left off with '#{__FILE__} --continue'.
WARNING
      exit 1
    else
      migrate(opt['version'], false, nil, migrate_position, num_migrators)
    end
  else
    puts "--version is required"
    exit 255
  end
end
