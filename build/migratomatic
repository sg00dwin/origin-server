#!/usr/bin/env ruby

require 'getoptlong'
require 'tempfile'
require 'yaml'

def verbose(msg)
  if VERBOSE
    puts "#{msg}\n"
  end
end

def command(cmd) 
  verbose "Running: \"#{cmd}\""

  if !DRY_RUN
    output = `#{cmd}`
    cmd_output(output)
  end

  output.chomp
end

def cmd_output(output)
  verbose "Output: \n=====\n#{output}\n====="
end

def generate_token
  rand(36**8).to_s(36)
end

def pull_artifacts(mig_config, devenv, version)
  puts "Pulling artifacts for #{version} from #{devenv}"

  command("rm -rf #{mig_config['tmp']}/#{version}; mkdir -p #{mig_config['tmp']}/#{version}")
  command("scp -r root@#{devenv}:devenv-local #{mig_config['tmp']}/#{version}")
  command("scp root@#{devenv}:/etc/yum.repos.d/local.repo #{mig_config['tmp']}/#{version}")
end

def create_devenv(mig_config, use_stage = true)
  env_type = use_stage ? "STAGE" : "LATEST"

  puts "Creating clean dev environment"

  token = generate_token
  user = ENV['USERNAME']
  env_name = "#{user}-migrations-#{env_type}-#{token}"

  cmd = "cd #{mig_config['repo_home']}/li;build/devenv launch #{env_name} 2>&1"

  if use_stage
    cmd += " --branch stage"
  end

  verbose "Running: \"#{cmd}\""

  if DRY_RUN 
    host = "DRYRUN_#{env_type}_DEVENV"
  else
    output = `#{cmd}`

    cmd_output(output)

    match = output.match(/Public Hostname:(.*)/)
    raise "Couldn't create devenv #{env_name}" unless match

    host = match[1].strip
    puts "Created devenv #{env_name} at #{host}"    
  end
 
  host
end

def create_config(mig_config, devenv)
  puts "Creating account on #{devenv}"
  token = generate_token

  account = "migratomatic-#{token}@example.com"

  config = <<EOF
libra_server=#{devenv}
default_rhlogin=#{account}
insecure=true
EOF

  config_file = "#{mig_config['tmp']}/migratomatic-#{token}.conf"

  puts "Writing temporary config file to #{config_file}"

  if !DRY_RUN
    open(config_file, "w") { |f|
      f.puts(config)
    }
  end

  save_config(mig_config, config_file)

  return account, token, config_file
end

def create_domain(domain, account, config, devenv)
  puts "Creating domain #{domain} for account #{account} on #{devenv}"
  
  command("rhc domain create --config #{config} -n #{domain} -p none 2>&1")

  if !DRY_RUN && $? != 0
    raise "Error creating domain, aborting" 
  end
end

def add_ssh_key(account, config, keyfile)
  puts "Adding SSH key to account #{account} from keyfile #{keyfile}"

  command("rhc sshkey add --config #{config} -p none default #{keyfile}")

  if !DRY_RUN && $? != 0
    raise "Error adding SSH key, aborting"
  end
end

def up_gears(devenv, account)
  cmd = "ssh root@#{devenv} oo-admin-ctl-user -l #{account} --setmaxgears 50 2>&1"

  puts "Setting max gears to 100"

  command(cmd)
end

def generate_apps(app_descriptors, domain)
  puts "Generating apps for #{app_descriptors.length} cartridge combinations"

  apps = []

  app_descriptors.each do |app_def|
    apps << generate_app(app_def, domain)
  end

  apps
end

def generate_app(app_descriptor, domain)
  cart_name = app_descriptor[:type].gsub(/-|\./,'')
  token = generate_token
  
  app = {
    :token => token,
    :old_name => "old#{cart_name}#{token}",
    :new_name => "new#{cart_name}#{token}",
    :domain => domain,
    :scalable => !!app_descriptor[:scalable], # coerce a boolean for scalable
    :type => app_descriptor[:type],
    :embedded => app_descriptor[:embedded]
  }

  app
end

def create_apps(mig_config, apps, config)
  puts "Creating #{apps.length} pre-migration apps"
  
  apps.each do |app|
    puts "  Creating app #{app[:old_name]} (#{app[:type]}, #{app[:scalable] ? 'scalable' : 'unscalable'})"

    command = "rhc app create --config #{config} -a #{app[:old_name]} -t #{app[:type]} -p none 2>&1"
    command = "#{command} -s" if app[:scalable]
    verbose "Running: \"#{command}\""

    if !DRY_RUN
      Dir.chdir(mig_config['tmp']) do
        output = `#{command}`
        cmd_output(output)
        raise "Error creating app #{app[:old_name]}" unless $? == 0

        app[:embedded].each {|cart_type|
          cart_command = "rhc cartridge add --config #{config} -a #{app[:old_name]} -c #{cart_type} -p none 2>&1"
          puts "Running: \"#{cart_command}\"" if VERBOSE
          output = `#{cart_command}`
          cmd_output(output)
          raise "Error adding cartridge #{cart_type} to #{app[:type]}" unless $? == 0
        }
      end
    end 
  end
end

def store_apps(mig_config, apps) 
  puts "Saving apps to /#{mig_config['tmp']}/migratomatic-apps.dump"

  FileUtils.rm_rf("/#{mig_config['tmp']}/migratomatic-apps.dump")

  File.open("/#{mig_config['tmp']}/migratomatic-apps.dump", 'w') do |file|
    Marshal.dump(apps, file)
  end
end

def load_apps(mig_config)
  puts "Loading apps from /#{mig_config['tmp']}/migratomatic-apps.dump"

  unless File.exists?("/#{mig_config['tmp']}/migratomatic-apps.dump") 
    puts "Unable to load"
  end

  File.open("/#{mig_config['tmp']}/migratomatic-apps.dump") do |file|
    Marshal.load(file)
  end
end

def save_config(mig_config, config)
  puts "Saving RHC configuration from #{mig_config['tmp']}/migratomatic-config.txt"

  File.open(File.join(mig_config['tmp'], 'migratomatic-config.txt'), 'w') {|f| f.write(config)}
end

def load_config(mig_config)
  puts "Loading RHC configuration from #{mig_config['tmp']}/migratomatic-config.txt"

  IO.read("#{mig_config['tmp']}/migratomatic-config.txt").chomp
end

def load_rhlogin(config)
  content = IO.read(config).chomp

  match = content.match(/default_rhlogin=(.*)/)

  raise "Unable to load rhlogin from #{config}" unless match

  match[1]
end

def update_devenv(mig_config, devenv, new_version)
  puts "Updating devenv #{devenv}"

  command("scp -i ~/.ssh/libra.pem -r #{mig_config['tmp']}/#{new_version}/devenv-local root@#{devenv}:/root/")
  command("scp -i ~/.ssh/libra.pem #{mig_config['tmp']}/#{new_version}/local.repo root@#{devenv}:/etc/yum.repos.d/")

  command("ssh root@#{devenv} sed -i -e \"s/stage/candidate/g\" /etc/yum.repos.d/devenv.repo 2>&1")
  command("ssh root@#{devenv} \"yum -y update --enablerepo devenv-local 2>&1 > /root/update.#{new_version}.log\"")

  command("scp -i !/.ssh/libra.pem misc/maintenance/bin/{quarantine-all,migrate-mongo-#{new_version}} root@devenv:/root/")
  puts "Running quarantine-all and migrate-mongo-#{new_version}"
  command("ssh root@#{devenv} '/root/quarantine-all; [ -f /root/migrate-mongo-#{new_version} ] && /root/migrate-mongo-#{new_version}'")
end

def reboot_devenv(devenv) 
  command("ssh root@#{devenv} reboot")

  sleep 30

  while (command("ssh root@#{devenv} echo \"Success!\"") != 'Success!')
    sleep 5
  end
end

def save_comparison_apps(mig_config, devenv, apps, config)
  puts "Removing old comparison apps"

  apps.each do |app|
    app_symlink = "#{app[:new_name]}_#{app[:domain]}"
    command("ssh root@#{devenv} cp -r /var/lib/openshift/#{app_symlink} /tmp/#{app_symlink}")
  end
end

def migrate_apps(new_version, apps, devenv)
  puts "Migrating #{apps.length} applications"

  command("ssh root@#{devenv} \"rhc-admin-migrate --version #{new_version} >> /root/migrate.#{new_version}.log\"")

  if !DRY_RUN && $? != 0
    raise "Error migrating apps"
  end

  migrate_log = "/root/migrate.#{new_version}.log"   
end

def create_comparison_apps(old_to_new_cart_types, mig_config, apps, devenv, config)
  puts "Creating #{apps.length} post-migration apps for comparison"

  apps.each do |app|
    next if app[:type] == 'jenkins-1'

    app_symlink = "#{app[:new_name]}_#{app[:domain]}"

    if command("ssh root@#{devenv} \"if [ -d /tmp/#{app_symlink} ]; then echo 'Exists'; fi\"") == 'Exists'
      puts "App #{app[:new_name]} was already created."
    else
      app_type = old_to_new_cart_types[app[:type]] ? old_to_new_cart_types[app[:type]] : app[:type]  
      
      puts "Creating app #{app[:new_name]} (#{app_type}, #{app[:scalable] ? 'scalable' : 'unscalable'})"
      
      command = "rhc app create --config #{config} -a #{app[:new_name]} -t #{app_type} -p none 2>&1"
      command = "#{command} -s" if app[:scalable]
      verbose "Running: \"#{command}\""

      if !DRY_RUN
        Dir.chdir(mig_config['tmp']) do
          output = `#{command}`
          cmd_output(output)
          raise "Error creating app #{app[:new_name]}" unless $? == 0

          app[:embedded].each { |cart_type|
            cart_type = old_to_new_cart_types[cart_type] ||= cart_type
            command("rhc app cartridge add --config #{config} -a #{app[:new_name]} -c #{cart_type} -p none 2>&1")
            raise "Error adding cartridge #{cart_type} to #{app_type}" unless $? == 0
          }
        end
      end 
    end
  end
end

def diff_report(mig_config, apps, devenv)
  puts "Creating diff reports for #{apps.length} applications"

  apps.each do |app|
    next if app[:type] == 'jenkins-1'

    carts = ''
    app[:embedded].each {|cart_type|
      carts += "_#{cart_type}"
    }

    puts "Diffing #{app[:old_name]} against #{app[:new_name]} (#{app[:type]}#{carts}, #{app[:scalable] ? 'scalable' : 'unscalable'})"
    result_file = "/#{mig_config['tmp']}/#{app[:type]}#{carts}.#{app[:scalable] ? 'scalable' : 'unscalable'}.diff"

    command("ssh root@#{devenv} diff -r /var/lib/openshift/#{app[:old_name]}-* /var/lib/openshift/#{app[:new_name]}-* --exclude=repo > #{result_file} 2>&1")
  end
end

def cleanup(mig_config, devenv)
  puts "Cleaning up #{devenv}"

  command("cd #{mig_config['repo_dir']}/li; build/devenv terminate #{devenv} 2>&1")
end

def get_or_create_config()
  mig_home = File.join(File.expand_path('~'), ".migratomatic")
  mig_tmp = File.join(mig_home, "tmp")
  config_file = File.join(mig_home, "migratomatic.conf")

  Dir.mkdir(mig_home) unless File.directory?(mig_home)
  Dir.mkdir(mig_tmp) unless File.directory?(mig_tmp)

  if not File.exists?(config_file)
    puts "Creating new migratomatic config file at #{config_file}"
    
    default_config = {
      "mig_home" => mig_home,
      "tmp" => mig_tmp,
      "repo_home" => "/home/user/openshift",
      "default_keyfile" => "/home/user/.ssh/id_rsa.pub"
    }

    writable_config_file = File.open(config_file, 'w')
    
    YAML.dump(default_config, writable_config_file)

    writable_config_file.close
  end

  return YAML.load_file(config_file)
end

def usage
  puts <<USAGE
build/migratomatic - setup, update, and migrate a stage instance to a newer version

usage: build/migratomatic [-V,--verbose] [-D,--dry-run]
                          [-v,--version] <version> [-c,--command] <command> [-d,--devenv] <devenv host> 

commands:
  help:            see this message
  pull-artifacts:  pull artifacts (devenv-local, local.repo) from a devenv
  create:          create a devenv from the latest stage ami
  setup:           create a domain and pre-migration apps
  update:          update a devenv to a new version
  migrate:         migrate apps to a new version
  diff:            create comparison apps and diff reports
  test:            the whole \#!
USAGE
end

def app_descriptions
  [ { type: 'jbossas-7', 
      embedded: %w(postgresql-8.4) },
    { type: 'php-5.3', 
      embedded: %w(postgresql-8.4),
      scalable: true },
    { type: 'php-5.3',
      embedded: %w(mysql-5.1 phpmyadmin-3) }
  ]
end

def old_to_new_cart_types
  {}
end

opt = {}

begin
    opts = GetoptLong.new(
        ["--help",    "-h", GetoptLong::NO_ARGUMENT],
        ["--verbose", "-V", GetoptLong::NO_ARGUMENT],
        ["--dry-run", "-D", GetoptLong::NO_ARGUMENT],
        ["--version", "-v", GetoptLong::REQUIRED_ARGUMENT],
        ["--command", "-c", GetoptLong::REQUIRED_ARGUMENT],
        ["--devenv",  "-d", GetoptLong::REQUIRED_ARGUMENT]
    )

    opts.each do |o, a|
      if (o == "--help") or (o == "-h")
        usage
        exit
      end

      opt[o[2..-1]] = a.to_s
    end
rescue Exception => e
  puts e
  usage
  exit
end

puts opt.to_s

DRY_RUN = opt['dry-run'] 
VERBOSE = opt['verbose']

new_version = opt['version']
command = opt['command']

if new_version.nil? || command.nil?
  usage
  exit
end

if !%w(create test).include?(opt['command']) && !opt['devenv']
  usage
  exit
end

mig_config = get_or_create_config

puts "Loaded migratomatic config: #{mig_config.inspect}"

case command
when 'pull-artifacts'
  devenv = opt['devenv']
  pull_artifacts(mig_config, devenv, new_version)
when 'test'
  devenv = create_devenv(mig_config, true)
  account, domain, config = create_config(mig_config)
  create_domain(domain, account, config, devenv)
  add_ssh_key(account, config, mig_config['default_keyfile'])
  up_gears(devenv, account)
  apps = generate_apps(app_descriptions, domain)
  create_apps(mig_config, apps, config)
  store_apps(mig_config, apps)
  update_devenv(mig_config, devenv, new_version)
  migrate_apps(new_version, apps, devenv)
  create_comparison_apps(old_to_new_cart_types, mig_config, apps, devenv, config)
  diff_report(mig_config, apps, devenv)
  cleanup(mig_config, devenv)
when 'create'
  devenv = create_devenv(mig_config, true)
  puts "devenv: #{devenv}"
when 'setup'
  devenv = opt['devenv']
  account, domain, config = create_config(mig_config, devenv)
  create_domain(domain, account, config, devenv)
  add_ssh_key(account, config, mig_config['default_keyfile'])
  up_gears(devenv, account)
  apps = generate_apps(app_descriptions, domain)
  create_apps(mig_config, apps, config)
  store_apps(mig_config, apps)
when 'update'
  devenv = opt['devenv']
  update_devenv(mig_config, devenv, new_version)
when 'migrate'
  devenv = opt['devenv']
  apps = load_apps(mig_config)
  config = load_config(mig_config)
  account = load_rhlogin(config)
  migrate_apps(new_version, apps, devenv, account)
when 'diff'
  devenv = opt['devenv']
  apps = load_apps(mig_config)
  config = load_config(mig_config)
  create_comparison_apps(old_to_new_cart_types, mig_config, apps, devenv, config)
  diff_report(mig_config, apps, devenv)
when 'help'
  usage
else
  puts "supported commands: pull-artifacts|create|setup|update|migrate|diff|test|help"
end
