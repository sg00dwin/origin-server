#!/bin/sh
#
# libra-cgroups This shell script initializes libra control groups
#
# Author:       Seth Vidal <skvidal@phy.duke.edu>
#               Mike McGrath <mmcgrath@redhat.com>
#               Mark lamourine <markllama@redhat.com>
#
# chkconfig:    345 6 94
#
# description:  Create Libra user cgroups
# processname:  NA
#

# source function library
. /etc/rc.d/init.d/functions

# import libra cgroups settings
if [ -f /etc/sysconfig/libra-cgroups ]
then
    . /etc/sysconfig/libra-cgroups
fi

lockfile=/var/lock/subsys/libra-cgroups

if [ -f /etc/stickshift/stickshift-node.conf ]
then
    . /etc/stickshift/stickshift-node.conf
fi

if [ -f /etc/stickshift/resource_limits.conf ]
then
    . /etc/stickshift/resource_limits.conf
fi

RETVAL=0
GROUP_RETVAL=0

#
# Set defaults if not provided
#
LIBRA_CGROUP_ROOT=${LIBRA_CGROUP_ROOT:="/libra"}
LIBRA_CGROUP_SUBSYSTEMS=${LIBRA_CGROUP_SUBSYSTEMS:="cpu,cpuacct,memory,net_cls,freezer"}

CGROUP_RULES_FILE=${CGROUP_RULES_FILE:="/etc/cgrules.conf"}

CPU_VARS="cfs_period_us cfs_quota_us rt_period_us rt_runtime_us shares"
MEM_VARS="limit_in_bytes memsw_limit_in_bytes soft_limit_in_bytes swappiness"

# Get a user's UID
function uid() {
    grep -e "^$1:" /etc/passwd | cut -d: -f3
}

# get a user's home directory
function homedir() {
    grep -e "^$1:" /etc/passwd | cut -d: -f6
}

# ============================================================================
#  Functions for setting the net class
# ============================================================================

#
# Convert an MCS pair into a cgroup net class id
#
function classid() {
    # major: 1, minor UID
    printf "0x1%04x" $1
}

function set_net_cls() {
    # USERNAME=$1
    CGPATH=libra/$1
    USERID=`uid $1`
    USERCLASSID=`classid $USERID`
    #cgset -r net_cls.classid=$USERCLASSID $CGPATH
    # it turns out that net_cls doesn't REALLY want an MCS
    cgset -r net_cls.classid=$USERCLASSID $CGPATH
}

# ==========================================================================
#  Functions for tuning the user's CPU limits in cgroups
# ==========================================================================
CPUVARS="cfs_period_us cfs_quota_us rt_period_us rt_runtime_us shares"
function set_cpu() {
    # USERNAME=$1
    CGPATH=libra/$1

    for VARNAME in $CPUVARS
    do
	# cgroups names can have periods(.)  shell varnames can't
	SAFENAME=`echo $VARNAME | tr . _`
	VALUE=`eval echo \\$cpu_$SAFENAME`
	if [ -n "${VALUE}" ]
	then
	    # TODO: get per-app increments
	    cgset -r "cpu.$VARNAME=$VALUE" $CGPATH
	fi
    done
}

# ==========================================================================
#  Functions for tuning the user's memory limits in cgroups
# ==========================================================================
MEMVARS="limit_in_bytes memsw.limit_in_bytes soft_limit_in_bytes swappiness"
function set_memory() {
    # USERNAME=$1
    CGPATH=libra/$1

    # for each var get and set the value
    for VARNAME in $MEMVARS
    do
	# cgroups names can have periods(.)  shell varnames can't
	SAFENAME=`echo $VARNAME | tr . _`
	VALUE=`eval echo \\$memory_$SAFENAME`
	if [ -n "${VALUE}" ]
	then
	    # TODO: get per-app increments
	    cgset -r "memory.$VARNAME=$VALUE" $CGPATH
	fi
    done
}

# ==========================================================================
#  Functions for tuning the user's memory limits in cgroups
# ==========================================================================
BLKIOVARS="weight weight_device"
function set_blkio() {
    # USERNAME=$1
    CGPATH=/$1

    # for each var get and set the value
    for VARNAME in $BLKIOVARS
    do
	# cgroups names can have periods(.)  shell varnames can't
	SAFENAME=`echo $VARNAME | tr . _`
	VALUE=`eval echo \\$blkio_$SAFENAME`
	if [ -n "${VALUE}" ]
	then
	    # TODO: get per-app increments
	    # TODO: weight_device should really use the user's home device
	    #       and set the rest (if any) to 0
	    # cgset -r "blkio.$VARNAME=$VALUE" $CGPATH
	    echo nothing >>/dev/null
	fi
    done
}

# List the libra guest users
#
libra_users() {
    grep 'libra guest' /etc/passwd | cut -d: -f1
}

valid_user() {
    # check if the user name exists and is tagged as a libra guest user
    grep ":libra guest:" /etc/passwd | cut -d: -f1 | grep -e "^$1\$" >/dev/null 2>&1
}

#
# Create a new libra user cgroup
#
add_cgroup() {
    # USERNAME=$1
    cgcreate -t $1:$1 -g ${LIBRA_CGROUP_SUBSYSTEMS}:${LIBRA_CGROUP_ROOT}/$1
}

#
# Delete a libra user cgroup
#
delete_cgroup() {
    # USERNAME=$1
    cgdelete ${LIBRA_CGROUP_SUBSYSTEMS}:${LIBRA_CGROUP_ROOT}/$1
}


#
# check which user cgroups exist
#
cgroup_user_subsystems() {
    # USERNAME=$1
    lscgroup | grep ":${LIBRA_CGROUP_ROOT}/$1\$" | cut -d: -f1
}

#
# Check that a group binding rule exists for a user
#
cgroup_rule_exists() {
    #USERNAME=$1
    # remove comments, get first field, match exactly, quiet
    grep -v '^#' ${CGROUP_RULES_FILE} | cut -f1 | grep -q -x $1
}


#
# Bind the user to the cgroup: update /etc/cgrules.conf and kick cgred
#
add_cgroup_rule() {
    # USERNAME=$1
    cat <<EOF >>${CGROUP_RULES_FILE}
$1	$LIBRA_CGROUP_SUBSYSTEMS	$LIBRA_CGROUP_ROOT/$1
EOF
}

#
# Unbind the user from any cgroup
#
delete_cgroup_rule() {
    # USERNAME=$1
    sed -i -e "/^$1\s/d" ${CGROUP_RULES_FILE}
}

startuser() {
    NEWUSER=$1

    echo -n "starting cgroups for $NEWUSER..."

    add_cgroup $NEWUSER
    if [ $? != 0 ]
    then
        RETVAL=$?
    fi

    set_cpu $NEWUSER
    set_memory $NEWUSER
    #set_blkio $NEWUSER
    set_net_cls $NEWUSER

    # CHECK: don't trust old rules
    if ( cgroup_rule_exists $NEWUSER )
    then
        delete_cgroup_rule $NEWUSER
    fi
    add_cgroup_rule $NEWUSER
    if [ $? != 0 ]
    then
        RETVAL=$?
    fi

    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi
    echo
}


start() {
    echo "Initializing Libra guest control groups: "

    if !(service cgconfig status >/dev/null)
    then
       RETVAL=1
       GROUP_RETVAL=3
       echo "cgconfig service not running"

       return $GROUP_RETVAL
    fi

    # create the root of the libra user control group
    add_cgroup # defaults to creating the root group
    RETVAL=$?

    # This won't scale forever, but works fine in the '100 or so' range
    for USERNAME in `libra_users`
    do
        startuser $USERNAME
    done

    # kick the Cgroups rules daemon
    service cgred reload

    [ $GROUP_RETVAL -eq 0 ] && touch ${lockfile}
    [ $GROUP_RETVAL -eq 0 ] && success || failure

    echo -n $"Libra cgroups initialized"
    echo
    return $GROUP_RETVAL
    echo
    echo "WARNING !!! WARNING !!! WARNING !!!"
    echo "Cgroups may have just restarted.  It's important to confirm all the libra apps are actively running."
    echo "It's suggested you run service libra restart now"
    echo "WARNING !!! WARNING !!! WARNING !!!"
    echo
}


stopuser() {
    DELUSER=$1
    echo -n "stopping cgroups for $DELUSER..."

    # kill any processes owned by these users
    #pkill -u $DELUSER
    
    # remove the user's cgroup
    delete_cgroup $DELUSER
    if [ $? != 0 ]
    then
	RETVAL=$?
    fi
    
    # remove the user's cgroup binding rule
    delete_cgroup_rule $DELUSER
    if [ $? != 0 ]
    then
	RETVAL=$?
    fi

    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi
}

stop() {
    echo "Removing Libra guest control groups: "

    if !(service cgconfig status >/dev/null)
    then
       RETVAL=1
       GROUP_RETVAL=3
       echo "cgconfig service not running"

       return $GROUP_RETVAL
    fi

    # This won't scale forever, but works fine in the '100 or so' range
    for USERNAME in `libra_users`
    do
	stopuser $USERNAME
    done

    # notify the cgroup rule daemon
    service cgred reload

    # remove the libra root cgroup
    delete_cgroup

    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi

    [ $GROUP_RETVAL -eq 0 ] && touch ${lockfile}
    echo -n $"Libra cgroups uninitialized"
    echo
    return $GROUP_RETVAL
}

restart() {
    stop
    start
}

status() {
    echo "Checking Libra Services: "

    lscgroup | grep -e  ":${LIBRA_CGROUP_ROOT}\$" >/dev/null 2>&1
    if [ $? -ne 0 ]
    then
	echo "Libra cgroups uninitialized"
	echo
	return 1
    else
	echo "Libra cgroups initialized"
    fi
    
    if [ -z "$1" ]
    then
	USERLIST=`libra_users`
    else
        USERLIST=$1
    fi

    # check that the /libra cgroup exists

    # This won't scale forever, but works fine in the '100 or so' range
    #  would be easy to convert to a 'in `find...`'     jj
    for USERNAME in $USERLIST
    do
	# check that /libra/<username> exists
	SUBSYSTEMS=`cgroup_user_subsystems`
	if ( cgroup_rule_exists $USERNAME )
        then
	    RETVAL=0
            BOUND="BOUND"
        else
	    RETVAL=1
            BOUND="UNBOUND"
        fi

	echo -n "${USERNAME}: $BOUND	" `echo $SUBSYSTEMS | tr ' ' ,`
	# check that cgrule exists

        if [ $RETVAL -eq 0 ]
        then
            echo_success
        else
            GROUP_RETVAL=$(($GROUP_RETVAL+1))
            echo_failure
        fi
	echo
    done
    return $GROUP_RETVAL
}


case "$1" in
  start)
    start
    ;;

  stop) 
    stop
    ;;

  restart|force-reload|reload)
    restart
    ;;

  condrestart)
    [ -f "$lockfile" ] && restart
    ;;

  status)
    status $2
    ;;

  startuser)
    if (service cgconfig status >/dev/null)
    then
        startuser $2
        service cgred reload
    else
        RETVAL=1
        echo "cgconfig service not running"
    fi
    ;;

  stopuser)
    if (service cgconfig status >/dev/null)
    then
        stopuser $2
        service cgred reload
    else
        RETVAL=1
        echo "cgconfig service not running"
    fi
    ;;

  *)
    echo $"Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart|startuser <username>|stopuser <username>}"
    exit 1
esac

exit $RETVAL
